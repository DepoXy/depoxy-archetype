# vim:tw=0:ts=2:sw=2:et:norl:nospell:ft=bash

# USAGE:
#   m4_shim \
#     "+15" ".mrconfigs/_mrconfig.EVAL.omr" \
#     ".mrconfigs/_mrconfig"

# KEEP FRESH:
#   meld ~/.depoxy/ambers/archetype/.mrconfigs/_mrconfig.EVAL.omr ~/.depoxy/running/.mrconfigs/_mrconfig &
# Or swap directions:
#   meld ~/.depoxy/running/.mrconfigs/_mrconfig ~/.depoxy/ambers/archetype/.mrconfigs/_mrconfig.EVAL.omr &

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# vim:tw=0:ts=2:sw=2:et:norl:nospell:ft=bash
# DXY_HEADER_AUTHOR
# DXY_HEADER_PROJECT
# DXY_HEADER_LICENSE

# ****************************************************************************************

# *** NOTE: THIS MRCONFIG ONLY RUNS ON THE CLIENT MACHINE / CLIENT-ONLY ***

[DEFAULT]
__USYNC__ =
  meld \
    DXY_DEPOXYARCHETYPE_DIR_TILDE/.mrconfigs/_mrconfig.EVAL.omr \
    ~/.depoxy/running/.mrconfigs/_mrconfig &

# ========================================================================
# ------------------------------------------------------------------------

[DEFAULT]
order = 133

# ========================================================================
# ------------------------------------------------------------------------

[${DEPOXYDIR_STINTS_FULL:-DXY_DEPOXYDIR_STINTS__HOME_}/DXY_DEPOXY_CLIENT_ID]
order = 129
# The client remote has no remote unless you add one for it.
# - See the private remotes config for where to set the remote:
#     DXY_DEPOXYDIR_STINTS_TILDE/DXY_DEPOXY_CLIENT_ID/.mrconfigs/_mrconfig-remotes
checkout = [ -z "${MR_REPO_REMOTES}" ] || mr_repo_checkout
#
fetch = true
pull = true
push = true
update = true
skip = mr_exclusive "client"
infuseProjlns = OMR_INFUSE_PROJLNS_ROOT=true infuse_projlns_if_personal_project

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

lib =
  #
  CLEARED_ACI="Entrust: autoci"
  PRIVATE_ACI="PRIVATE: autoci*"
  #
  git_auto_commit_one_docs () {
    git_auto_commit_one "$1" -m "${3:-${CLEARED_ACI}}: Docs: ${2:-$1}"
  }
  #
  git_auto_commit_one_omr () {
    git_auto_commit_one "$1" -m "${3:-${CLEARED_ACI}}: OMR: Update: ${2:-$1}"
  }
  #
  git_auto_commit_one_update () {
    git_auto_commit_one "$1" -m "${3:-${CLEARED_ACI}}: Update: ${2:-$1}"
  }
  #
  # SAVVY: The `git_auto_commit_many` calls below assume no spaces in paths.
  # - Specifically, the `find` usage breaks on spaces, e.g.,
  #     git_auto_commit_many $(find private/docs/ -type f -o -type l) \
  #       -m "${CLEARED_ACI}: Docs: Personal notes"
  # - If we cared, an eval wrapper with quoted `find` output could work, e.g.,
  #     eval git_auto_commit_many \
  #       "$(find private/docs/ \( -type f -o -type l \) -a -printf '"%f" ')" \
  #       -m "${CLEARED_ACI}: Docs: Personal notes"

autocommit =
  # For completeness `git ls-files`, we ensure that all repo files are under
  # autocommit (or documented why not). And for comparability for `ls-files`,
  # we list files in the same order.
  # - SAVVY: Don't spent time crafting more helpful commits for the DXC project.
  #   You can craft better commits if/when you merge back to the DXA template
  #   project, but the client itself is ephemeral (you'll abandon the project
  #   when you move on to the next Client), so you needn't bother maintaining
  #   a more ideal Git history (just shovel everything into the repo and move
  #   on).
  #
  # ***
  #
  local depoxy_client_id="$(basename -- "${MR_REPO}")"
  #
  # Prepare args, e.g., `autocommit -y`, or `autocommit -f`.
  git_auto_commit_parse_args "$@"
  #
  local ambers_path="${DEPOXYAMBERS_DIR:-DXY_DEPOXYAMBERS_DIR__HOME_}"
  #
  # ***
  #
  # NOTE: Many/all of the `find` calls below fail if any paths contain spaces.
  #
  # ***
  #
  git_auto_commit_one_update ".gitignore"
  git_auto_commit_one_update ".hostnames"
  git_auto_commit_one_update ".ignore"
  git_auto_commit_one_update "LICENSE"
  #
  # ***
  #
  git_auto_commit_one_omr ".mrconfigs/_mrconfig"
  git_auto_commit_one_omr ".mrconfigs/_mrconfig-DXY_USERNAME"
  #
  # - Auto-commit just ".mrconfigs/_mrconfig-DXY_VENDOR_NAME":
  #     git_auto_commit_one_omr ".mrconfigs/_mrconfig-DXY_VENDOR_NAME" "" "${PRIVATE_ACI}"
  # - Auto-commit ".mrconfigs/_mrconfig-DXY_VENDOR_NAME" and the project-specific configs:
  local bizconfs="$(\
    find ".mrconfigs/" \
      -name "_mrconfig-DXY_VENDOR_NAME" \
      -o -name "_mrconfig-DXY_VENDOR_NAME--*" \
  )"
  if [ -n "${bizconfs}" ]; then
    git_auto_commit_many ${bizconfs} \
      -m "${PRIVATE_ACI}: OMR: Update: .mrconfigs/_mrconfig-DXY_VENDOR_NAME[--*]"
  fi
  #
  git_auto_commit_one ".mrconfigs/_mrconfig-DXY_VENDOR_NAME" \
    -m "${CLEARED_ACI}: DXA: OMR: Update: .mrconfigs/_mrconfig-DXY_VENDOR_NAME"
  #
  # ***
  #
  for path in \
    "README"* \
    ".whilom/README"* \
  ; do
    if [ -f "${path}" ]; then
      git_auto_commit_one_docs "${path}"
    fi
  done
  #
  # ***
  #
  # Ideally, .whilom/ files would be scoped the same as they'd be at the
  # same path under root DXC/. But this is a rarely-used, niche feature,
  # so follow this convention: Use .whilom/home/DXY_VENDOR_HOME_NAME/ for PRIVATE files.
  # Anything else under .whilom/ will be auto-committed unscoped.
  if [ -d ".whilom/home/DXY_VENDOR_HOME_NAME/" ]; then
    git_auto_commit_many $(find .whilom/home/DXY_VENDOR_HOME_NAME/ -type f -o -type l) \
      -m "${PRIVATE_ACI}: Update: .whilom/home/DXY_VENDOR_HOME_NAME/"
  fi
  git_auto_commit_many $(find .whilom/ -type f -o -type l) \
    -m "${CLEARED_ACI}: Update: .whilom/"
  #
  # ***
  #
  # Vendor-related reSTfold docs.
  #
  git_auto_commit_one_update "docs/.ignore" "" "${PRIVATE_ACI}"
  #
  # git_auto_commit_many \
  #   "docs/Backlog_Client_${depoxy_client_id}.rst" \
  #   "docs/Donelog_Client_${depoxy_client_id}.rst" \
  #   "docs/Woodlot_Client_${depoxy_client_id}.rst" \
  #   "docs/Worklog_Client_${depoxy_client_id}.rst" \
  #   -m "PRIVATE: autoci: Docs: Work notes."
  #  #-m "PRIVATE: autoci: Update: Docs."
  #
  # NOTE: Enable MRT_LINK_FORCE so ' T' git-status typechanges are included.
  MRT_LINK_FORCE=0 git_auto_commit_many $(find docs/ -type f -o -type l) \
    -m "${PRIVATE_ACI}: Docs: Work notes"
  #
  # ***
  #
  git_auto_commit_one_update "home/.config/depoxy/depoxyrc" "depoxyrc"
  git_auto_commit_one_update "home/.config/depoxy/321open.cfg" "321open.cfg"
  #
  git_auto_commit_one_update "home/.config/karabiner/README.rst"
  git_auto_commit_one_update \
    "home/.config/karabiner/assets/complex_modifications/3110-client-DXY_DEPOXY_CLIENT_ID-private.json.example"
  git_auto_commit_one_update \
    "home/.config/karabiner/assets/complex_modifications/9210-privte-docs-launchers-private.json"
  #
  git_auto_commit_one_update "home/.config/karabiner/karabiner.json"
  #
  git_auto_commit_one_update "home/.config/tig/config"
  #
  # *** Other home/.*
  #
  if [ -d "${HOME}/.aws" ]; then
    mkdir -p "${MR_REPO}/home/.aws"
    command cp -- "${HOME}/.aws/config" "${MR_REPO}/home/.aws/config"
    command cp -- "${HOME}/.aws/credentials" "${MR_REPO}/home/.aws/credentials"
    git_auto_commit_many $(find home/.aws/ -type f -o -type l) \
      -m "${PRIVATE_ACI}: Update: home/.aws/ files"
  fi
  #
  git_auto_commit_one_update "home/.depoxy/_gitignore"
  git_auto_commit_one_update "home/.depoxy/stints/_ignore"
  #
  git_auto_commit_one_update "home/.depoxy/stints/running/DXY_VENDOR_DOTFILES_NAME/README.md"
  #
  git_auto_commit_one_update "home/.finicky.js" "~/.finicky.js config."
  #
  git_auto_commit_one_update "home/.gitconfig.user"
  git_auto_commit_one_update "home/.gitconfig.user-business" "" "${PRIVATE_ACI}"
  git_auto_commit_one_update "home/.gitconfig.user-personal"
  #
  git_auto_commit_one_update "home/.kit/_git/info/exclude"
  #
  # We track ~/.kube/config by copying it...
  if [ -f "${HOME}/.kube/config" ]; then
    command cp -- "${HOME}/.kube/config" "${MR_REPO}/home/.kube/config"
    #
    git_auto_commit_many $(find home/.kube/ -type f -o -type l) \
      -m "${PRIVATE_ACI}: Update: home/.kube/ files"
  fi
  git_auto_commit_one_update "home/.kube/PRIVATE"
  #
  git_auto_commit_one_update "home/.local/share/dob/dob.sqlite"
  # E.g., home/.local/share/dob/dob.sqlite-user-template
  # - BWARE: This call breaks if any found path contains spaces.
  git_auto_commit_many $(find home/.local/share/dob/ \( -type f -o -type l \) -a -name dob.sqlite-*) \
    -m "${CLEARED_ACI}: Update: home/.local/share/dob/dob.sqlite-* files"
  #
  if [ -f "home/.netrc" ]; then
    git_auto_commit_one_update "home/.netrc" "" "${PRIVATE_ACI}"
  fi
  #
  if [ -f "home/.npmrc" ]; then
    git_auto_commit_one_update "home/.npmrc" "" "${PRIVATE_ACI}"
  fi
  #
  # *** Key Paddock backups
  #
  # SAVVY: The "Key Paddock" is a specific path on an encrypted file system,
  # deliberately mounted by the user, used to persist security-related files.
  # - Specifically, the key paddock hosts ~/.gnupg/, ~/.password-store/, and
  #   ~/.ssh/ (and those home paths are each a symlink to the paddock path).
  # - CXREF: ~/.kit/odd/321open/lib/biblio.321
  #     # E.g., /Volumes/vestige/.clench
  #     ${ONEOPEN_KEYS_PADDOCK:-${ONEOPEN_MOUNTPOINT:-/Volumes}/${DMG_ENCFS_IMAGE_NAME:-vestige}/.clench}
  # - For a personal DepoXy Client, you should just sync (git-fetch/git-pull)
  #   the paddock repo (and the separate ~/.password-store repo) between your
  #   own hosts.
  # - But on a Vendor machine (the common DepoXy Client use case), many GPG,
  #   SSH, and PWDs are for Vendor resources. And you shouldn't want (nor
  #   might legally have a reason) to have a copy of these resources on
  #   a personal device.
  # - But if you have any personal keys on the Vendor machine, e.g., a personal
  #   GitHub SSH key, or, e.g., the Password Store GPG key, that you want to
  #   backup personally, you can use the following sections to copy whatever
  #   GPG, SSH, and Password Store entries you want to the DepoXy Client.
  #   And then you can sync the Client between the Vendor machine and your
  #   personal host like you normally would, and your personal keys will be
  #   captured.
  #
  # *** GPG Keys
  #
  aci_gnupg () {
    . "${DOPP_KIT:-${HOME}/.kit}/odd/321open/lib/biblio.321"
    #
    local dxy_target="home/.gnupg"
    #
    local bkup_public="${dxy_target}/public.gpg"
    local bkup_private="${dxy_target}/private.gpg"
    local bkup_trust="${dxy_target}/trust.gpg"
    #
    local mru_private_key="${HOME}/.gnupg/$( \
      command ls -1t "${HOME}/.gnupg/private-keys-v1.d/" | head -n 1
    )"
    #
    if true \
      && [ "${bkup_public}" -nt "${HOME}/.gnupg/pubring.gpg" ] \
      && [ "${bkup_private}" -nt "${mru_private_key}" ] \
      && [ "${bkup_trust}" -nt "${HOME}/.gnupg/trustdb.gpg" ] \
    ; then
      debug "$(fg_mintgreen)$(attr_emphasis)bkups uptodate$(attr_reset)" \
        "$(fg_lavender)$(pwd -L)/${dxy_target}/*.gpg$(attr_reset)"
      #
      return 0
    fi
    #
    # ***
    #
    # Assume if GPG dir or parent has .git/ that user doesn't need
    # GPG exports.
    if [ -f "${HOME}/.gnupg/.git/HEAD" ] \
      || [ -f "$(realpath -- "${HOME}/.gnupg")/../.git/HEAD" ] \
    ; then
      debug "$(fg_mintgreen)$(attr_emphasis)already repoed$(attr_reset)" \
        "$(fg_lavender)${HOME}/.gnupg$(attr_reset)"
      #
      return 0
    fi
    #
    # ***
    #
    # USAGE: List GPG key emails you want backed up, e.g.,
    #   key_emails="foo@bar baz@bat etc@and.so.forth"
    local key_emails="${ONEOPEN_PASSWORD_STORE_EMAIL}"
    #
    if [ -z "${key_emails}" ]; then
      debug "SKIPD: Configure ONEOPEN_PASSWORD_STORE_EMAIL to back up ~/.gnupg"
    else
      # Load: probe_if_gpg_passphrase_cached
      . "${DOPP_KIT:-${HOME}/.kit}/odd/321open/lib/biblio-gpg"
      #
      # Avoid prompting for passphrase during auto-commit.
      # - CPYST: Reload the agent to forget the cached password:
      #     gpg-connect-agent reloadagent /bye
      # - OWELL: `gpg --export-secret-keys` always prompts (or
      #   at least doesn't use the cached credentials).
      #   - So having this check doesn't help as intended, user will
      #     still be prompted by --export-secret-keys.
      #     - But at least they'll sorta know it's coming, because
      #       this see the ALERT, then cache their creds, then run
      #       infuse again, and be prompted again.
      if ! probe_if_gpg_passphrase_cached; then
        # All (some of?) the ways to cache a GPG key (for whatever the timeout is):
        #   pass ${ONEOPEN_PASSWORD_STORE_ADMIN}
        #   gpg -d ~/.password-store/${ONEOPEN_PASSWORD_STORE_ADMIN}.gpg
        # - Note that `gpg --export-secret-keys <email>` does *not* cache
        #   the key, and will always prompt for the passphrase.
        info "ALERT: Seed the key cache to backup GPG keys"
        info "- Note this tells the next '${MR_ACTION}' to backup keys,"
        info "  but gpg will still want it, so you'll be prompted again"
        if [ -n "${ONEOPEN_PASSWORD_STORE_EMAIL}" ]; then
          info "- E.g.,\n    echo foo | gpg -e -r ${ONEOPEN_PASSWORD_STORE_EMAIL} | gpg -d"
        fi
      else
        mkdir -p -- "${dxy_target}"
        #
        # REFER: Nice, consise backup-restore overview:
        #   https://www.howtogeek.com/816878/how-to-back-up-and-restore-gpg-keys-on-linux/
        command rm -f -- "${bkup_public}"
        gpg --export --export-options backup --output "${bkup_public}" \
          ${key_emails}
        # Tho secret key export requires passphrase, passphrase also required to restore this file.
        debug "Passphrase prompt for \`gpg --export-secret-keys\`..."
        command rm -f -- "${bkup_private}"
        gpg --export-secret-keys --export-options backup --output "${bkup_private}" \
          ${key_emails}
        command rm -f -- "${bkup_trust}"
        gpg --export-ownertrust > "${bkup_trust}"
        # How to restore:
        #   gpg --import public.gpg
        #   gpg --import private.gpg
        #   gpg --import-ownertrust trust.gpg
        #
        git_auto_commit_many $(find "${dxy_target}/" -type f 2> /dev/null) \
          -m "${CLEARED_ACI}: GPG backups"
      fi
    fi
  }
  aci_gnupg
  #
  # *** SSH
  #
  aci_ssh () {
    local dxy_target="home/.ssh"
    #
    for ssh_path in \
      "${HOME}/.ssh/config" \
      "${HOME}/.ssh/id_"* \
    ; do
      local source="${ssh_path}"
      local target="${dxy_target}/$(basename -- "${ssh_path}")"
      #
      # If source is a symlink, means user setup a seperate secrets repo,
      # so no need for us to backup the file.
      if [ ! -f "${source}" ] || [ -h "${source}" ]; then
        #
        continue
      fi
      #
      mkdir -p -- "${dxy_target}"
      #
      command cp -- "${source}" "${target}"
    done
    #
    git_auto_commit_many $(find "${dxy_target}/" -type f 2> /dev/null) \
      -m "${CLEARED_ACI}: SSH updates"
  }
  aci_ssh
  #
  # *** Password Store
  #
  aci_password_store () {
    # USAGE: Uncomment and customize if you want to backup
    #        part of ~/.password-store to the DepoXy Client.
    #
    # Use case: `pass` maintains ~/.password-store as its own Git repo.
    # - This lets you easily sync it with other machines, and to back it up,
    #   at least on personal machines, where all the passwords are personal.
    # - But on a Vendor machine (the whole point of a DepoXy Client), some
    #   passwords are for Vendor resources, and you shouldn't want (nor
    #   might legally have a reason) to have a copy of these passwords on
    #   a personal device.
    # - So list the passwords here you want copied to the DepoXy Client, and
    #   then sync the Client between the Vendor machine and personal hosts,
    #   but not the ~/.password-store itself.
    #
    # As an example, the following for-loop supposes you have a password,
    # `DXY_VENDOR_NAME/teams`, which you might need on, e.g., your smartphone
    # if the Vendor expects you to have access to chat from a personal
    # device.
    local dxy_target="home/.password-store"
    #
    for pass_path in \
      ".gpg-id" \
      "DXY_VENDOR_NAME/teams.gpg" \
    ; do
      local source="${HOME}/.password-store/${pass_path}"
      local target="${dxy_target}/${pass_path}"
      #
      if [ ! -f "${source}" ] || [ -h "${source}" ]; then
        #
        continue
      fi
      #
      mkdir -p -- "${dxy_target}"
      #
      command cp -- "${source}" "${target}"
    done
    #
    git_auto_commit_many $(find "${dxy_target}/" -type f) \
      -m "${CLEARED_ACI}: Password Store updates"
  }
  aci_password_store
  #
  # *** VIM
  #
  # User Vim config.
  depoxy_client_autocommit_vimprojects () {
    # CXREF: ~/.depoxy/ambers/bin/vimprojects-filter
    ${ambers_path}/bin/vimprojects-filter
    #
    git_auto_commit_one "home/.vim/pack/landonb/start/dubs_project_tray/.vimprojects" \
      -m "${PRIVATE_ACI}: Vimprojects         (Client project-tray drawer)"
    git_auto_commit_one "home/.vim/pack/landonb/start/dubs_project_tray/.vimprojects--purged" \
      -m "${CLEARED_ACI}: Vimprojects--purged (DepoXy projects only)"
    #
    # Dob, easy-as-pypi, and related Python projects.
    git_auto_commit_one "home/.vim/pack/landonb/start/dubs_project_tray/.vimprojects--dob" \
      -m "${CLEARED_ACI}: Vimprojects--dob"
  }
  depoxy_client_autocommit_vimprojects
  #
  git_auto_commit_one_update "home/.vim/pack/landonb/start/dubs_grep_steady/dubs_projects.vim" \
    "" "${PRIVATE_ACI}"
  #
  # Manage the spell file, and alert if parts differ from the whole.
  #   üé©ü™ÑüîÆ‚ú®  üßôüìöüëßü¶Åüè∞   ‚äÉ‚îÅ‚òÜÔæü
  debug "$(fg_mintgreen)$(attr_emphasis)conjure spells$(attr_reset)" \
    "üîÆ $(fg_lightblue)(‚à© Õ°¬∞ Õú ñ Õ°¬∞)‚äÉ‚îÅ‚òÜÔæü‚ú®$(attr_reset)"
  # Remove header and footer, e.g.,
  #   mr spells: /Users/user/.depoxy/stints/1234
  #   ...
  #  (.4 secs.) mr spells: finished (1 ok)
  # - Easy sol'n: -mM
  # - Hard sol'n: If not for -mM to inhibit `mr` annotation:
  #     ... | $(command -v gtail || command -v tail) -n +2 \
  #         | $(command -v ghead || command -v head) -n -1 ...
  #   - Noting that built-in macOS `head` lacks `-n` feature.
  SHCOLORS_OFF=false \
  SPF_PRINT_SPELLS=false mr -d . -n -mM spells "$@" 2>&1 \
    | sed 's/^/  /'
  #
  # ***
  #
  # SAVVY/2024-04-28: The Chrome Bookmarks capture is not completely
  # automated, but it's fairly close.
  # - If the user updates the "Bookmarks" file, we'll assume it's a raw
  #   copy of the original file. As such, it might contain private
  #   bookmarks (work org links), and we'll commit it PRIVATEly.
  # - If the user creates or updates any other file with a name that starts
  #   with "bookmarks" (case-insensitive), we'll commit that file unscoped.
  #
  # - MAYBE/2020-12-18: Update "Bookmarks" automatically.
  # - Either copy on 'autocommit'; or Symlink the actual Chrome bookmarks
  #   file to the DepoXy Client copy (setup the symlink on 'infuse', then
  #   whenever it changes, 'autocommit' will capture the changes).
  #   - Because the file is committed PRIVATE, this is "safe".
  #   - MAYBE: Don't over-commit, maybe throttle to daily commit.
  #
  # - MAYBE/2024-04-28: Use `jq` to "purify" a copy of the Bookmarks file.
  #   - You would need to omit PRIVATE bookmarks somehow.
  #     - One idea: Have user update environ or rules file to specifiy
  #       top-level BM Folder names to include in the "purged" copy.
  #
  depoxy_client_autocommit_chrome_bookmarks () {
    local chrome_dir
    if [ "$(uname)" = "Darwin" ]; then
      chrome_dir="Library/Application Support/Google/Chrome/Default"
    elif [ "$(uname)" = "Linux" ]; then
      chrome_dir=".config/google-chrome/Default"
    else
      fatal "ERROR: Unsupported, Unknown Platform: ‚Äú$(uname)‚Äù"
    fi
    #
    local chrome_bms_json="${chrome_dir}/Bookmarks"
    mkdir -p "home/${chrome_dir}"
    #
    # Chrome won't create this file until the user makes their first BM.
    # - MAYBE: As mentioned in comment above, symlink Chrome file to ours.
    if [ -f "${HOME}/${chrome_bms_json}" ]; then
      # Throttle commits to `-mtime +n` 24-hour periods since now.
      if [ ! -f "home/${chrome_bms_json}" ] \
        || [ -n "$(find "home/${chrome_bms_json}" -mtime +1 -print)" ] \
      ; then
        command cp -- "${HOME}/${chrome_bms_json}" "home/${chrome_bms_json}"
      fi
    fi
    git_auto_commit_one "home/${chrome_bms_json}" -m "${PRIVATE_ACI}: Chrome BMs (orig JSON)"
    #
    # We'll also assume any file named "bookmarks.html" is also private.
    local chrome_bms_html="${chrome_dir}/bookmarks.html"
    local its_been_awhile=false
    if [ -f "home/${chrome_bms_html}" ]; then
      git_auto_commit_one "home/${chrome_bms_html}" \
        -m "${CLEARED_ACI}: Chrome BMs (HTML export)."
      # I suppose we could always let the user know if it's been a while.
      if [ -n "$(find "home/${chrome_bms_html}" -mtime +13 -print)" ]; then
        its_been_awhile=true
      fi
    fi
    if ${DXY_ALERT_BMS_EXPORT:-false}; then
      if [ ! -f "home/${chrome_bms_html}" ] || ${its_been_awhile}; then
        if ${its_been_awhile}; then
          notice "STALE: It's been a while since you've exported Chrome Bookmarks HTML"
        fi
        notice "SAVVY: If you want, export Chrome bookmarks HTML to"
        notice "  $(echo "${MR_REPO}/home/${chrome_bms_html}" | sed 's/ /\\ /g')"
        notice "and we'll capture a private copy for you"
      fi
    fi
    #
    # MAYBE: See comment above re: Generated sanctified copy using `jq`, then, e.g.,
    #
    #  git_auto_commit_one "home/${chrome_bms_json}--purged" -m "${CLEARED_ACI}: Chrome BMs (sanitized)."
    #
    # - For now, user can generate such a file manually, and we'll happily
    #   auto-commit any other Bookmarks file here.
    #
    local bms_file
    find "home/${chrome_dir}" -maxdepth 1 -name "Bookmarks" -prune -o -iname "bookmarks*" -print \
      | while IFS= read -r bms_file \
    ; do
      git_auto_commit_one_update "${bms_file}"
    done
  }
  depoxy_client_autocommit_chrome_bookmarks
  #
  # ***
  #
  depoxy_client_autocommit_dob_assets () {
    git_auto_commit_one_update "home/Library/Application Support/dob/dob.conf"
    #
    if command -v dob > /dev/null; then
      dob --no-color export \
        -o "home/Library/Application Support/dob/dob.sqlite.export"
    else
      notice "ONBRD: üî≥ Install \`dob\`"
    fi
    #
    git_auto_commit_one "home/Library/Application Support/dob/dob.sqlite.export" \
      -m "${CLEARED_ACI}: Latest \\\`dob export\\\`."
  }
  depoxy_client_autocommit_dob_assets
  #
  # ***
  #
  git_auto_commit_one "home/_git/info/exclude" \
    -m "${CLEARED_ACI}: DX: Update ~/.gitignore.local"
  #
  # ***
  #
  git_auto_commit_one_update "home/bashrc.DXY_USERNAME.sh"
  git_auto_commit_one_update "home/bashrc.DXY_VENDOR_NAME.sh" "" "${PRIVATE_ACI}"
  git_auto_commit_one_update "home/bashrx.private.DXY_HOSTNAME.sh"
  #
  git_auto_commit_one_update "home/crontab.DXY_USERNAME" "" "${PRIVATE_ACI}"
  #
  git_auto_commit_one "home/dubs_projects.vim" \
    -m "${PRIVATE_ACI}: home/dubs_projects.vim (grep-steady mappings)"
  #
  # Symlink.
  git_auto_commit_one_update "home/.vimprojects"
  #
  git_auto_commit_many $(find home/vim-trap/ -type f -o -type l) \
    -m "${CLEARED_ACI}: Update: home/vim-trap/"
  #
  git_auto_commit_many $(find home/DXY_VENDOR_HOME_NAME/ -type f -o -type l) \
    -m "${PRIVATE_ACI}: Update: home/DXY_VENDOR_HOME_NAME/"
  #
  # ***
  #
  if [ -d "home/DXY_VENDOR_HOME_NAME" ]; then
    git_auto_commit_many $( \
      find home/DXY_VENDOR_HOME_NAME/ -path home/DXY_VENDOR_HOME_NAME/DXY_VENDOR_ACMESH_NAME -prune -o -type f -o -type l
    ) \
      -m "${PRIVATE_ACI}: Update: home/DXY_VENDOR_HOME_NAME/"
  fi
  #
  # ***
  #
  # Personal reSTfold docs.
  #
  git_auto_commit_many $(find private/docs/ -type f -o -type l) \
    -m "${CLEARED_ACI}: Docs: Personal notes"
  #
  git_auto_commit_one_update "private/private.not-private" "" "${PRIVATE_ACI}"
  #
  # ===
  # ***
  # ===
  #
  # *** Extras not related to `git ls-files` files.
  #
  # macOS Desktop file (delete).
  # - Toss the Desktop Services Store. It's created by Finder to store icon layout,
  #   background image, etc. But who uses Finder? Remove for less noisy `ls` output.
  command rm -f -- "./.DS_Store"
  #
  # ===
  # ***
  # ===
  #
  # *** Tree dumps. (Put this toward end, b/c some steps above create files.)
  #
  # Preserving DXC file listings might be of no utility to you, but it's
  # also nice to have an audit trail sometimes. So long as these commits
  # are not too noisy. (INERT: Should they be, add a timeout period.)
  #
  depoxy_client_autocommit_tree_dumps () {
    # Don't generate tree while spell changes outstanding,
    # because meld files come and go.
    if test -n "$(git status --porcelain -- home/.vim/spell)"; then
      return 0
    fi
    #
    tree -n -a -I .git/ -I "DXY_VENDOR_HOME__HOME_" > "home/.config/${depoxy_client_id}-tree.txt"
    tree -C -a -I .git/ -I "DXY_VENDOR_HOME__HOME_" > "home/.config/${depoxy_client_id}-tree.col"
    git_auto_commit_many \
      "home/.config/${depoxy_client_id}-tree.txt" \
      "home/.config/${depoxy_client_id}-tree.col" \
      -m "${CLEARED_ACI}: Client ${depoxy_client_id} project \\\`tree\\\`"
  }
  depoxy_client_autocommit_tree_dumps
  #
  # ===
  # ***
  # ===
  #
  insist_nothing_not_committed () {
    local ignore_spell_melds="$(echo \
      ":!home/.vim/spell/sync-spells--*-new.sh" \
      ":!home/.vim/spell/en.utf-8.add--*" \
    )"
    #
    if test -z "$(git status --porcelain -- ${ignore_spell_melds})"; then
      #
      return 0
    fi
    #
    >&2 error "ALERT: Found stray DXC files not registered with autocommit:"
    git status -s -- ${ignore_spell_melds} | >&2 sed 's/^.. /  /'
    #
    return 1
  }
  insist_nothing_not_committed

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

spells =
  git_auto_commit_parse_args "$@"
  # CXREF: ~/.depoxy/ambers/home/.kit/git/ohmyrepos/lib/spellfile.txt-runner.sh
  #   ~/.kit/txt/spellfile.txt/bin/spells.sh
  commit_sorted_spells_and_alert_if_conflicts
  git_auto_commit_one_update "home/.vim/spell/en.utf-8.add--personal" \
     "" "${PRIVATE_ACI}"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# CXREF: See GIT_POST_REBASE_EXEC usage.
# - Used post-rebase to remake hard links.
# SAVYY: Call link_hard from infusePostRebase, not infuse.
infusePostRebase =
  #
  # *** DepoXy filespace
  #
  # Remember that Git doesn't allow symlinked .gitignore .nomore.
  link_hard "${MR_REPO}/home/.depoxy/_gitignore" \
    "${DEPOXYDIR_BASE_FULL:-DXY_DEPOXYDIR_BASE__HOME_}/.gitignore"
  #
  # *** ~/.kube
  #
  # NOTE: If you create a new kubeconfig, copy to DXC manually, then infuse,
  #       then aci, it'll get picked up.
  for kubeconfig in "${MR_REPO}/home/.kube/"*.yaml; do
    # If nothing globbed, ${kubeconfig} is the glob string.
    if [ -f "${kubeconfig}" ]; then
      mkdir -p "${HOME}/.kube"
      #
      link_hard \
        "${kubeconfig}" \
        "${HOME}/.kube/$(basename -- "${kubeconfig}")"
    fi
  done

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

infuse =
  # Get the client name, e.g., 'XXXX' from DXY_DEPOXYDIR_STINTS_TILDE/XXXX.
  local depoxy_client_id="$(basename -- "${MR_REPO}")"
  #
  local ambers_path="${DEPOXYAMBERS_DIR:-DXY_DEPOXYAMBERS_DIR__HOME_}"
  #
  # *** `mredit` wiring
  #
  # CXREF: DXY_DEPOXY_PROJLNS_DIR_TILDE/mymrconfigs/
  symlink_overlay_file \
    "${MR_REPO}/.mrconfigs/_mrconfig" \
    "${MREDIT_CONFIGS:-${DEPOXY_PROJLNS:-${HOME}/.projlns}/mymrconfigs}/client-${depoxy_client_id}-mrconfig"
  #
  # *** Guard clause
  #
  # Stop now if *not* the active DepoXy Client
  #
  #   (the tasks below will overwrite the active client's
  #    symlinks and make this project the active client)
  #
  # Check if this is the active client, and stop now if not.
  # - Normally, the active client is specified by DEPOXY_CLIENT_ID
  #     hard-coded from ~/.config/depoxy/depoxyrc
  #   Or it's the largest-numbered client under stints/
  #     per default used by ~/.depoxy/ambers/core/depoxy_fs.sh
  # - But in the context of OMR config, the active client is
  #   the one specified by ~/.depoxy/running, because it's this
  #   infuse action (see below) that wires ~/.config/depoxy/depoxyrc
  #   - So deploy-archetype.sh (or the user) can point
  #     ~/.depoxy/running at the client they want to activate,
  #     and then run `mr -d ~/.depoxy/running infuse` to wire it.
  #
  local depoxydir_running_full="${DEPOXYDIR_RUNNING_FULL:-DXY_DEPOXYDIR_RUNNING__HOME_}"
  local running_now="$(realpath -- "${depoxydir_running_full}")"
  local project_abs="$(realpath -- "${MR_REPO}")"
  if [ "${project_abs}" != "${running_now}" ]; then
    warn "BWARE: This is not the active client"
    warn "- That honor goes to"
    warn "    ${running_now}"
    warn "- To make this project the active client, try"
    warn "    command rm \"${depoxydir_running_full}\""
    warn "    command ln -s \\"
    warn "      \"${MR_REPO}\" \\"
    warn "      \"${depoxydir_running_full}\""
    warn "    mr -d \"${MR_REPO}\" -n infuse"
    #
    return 1
  fi
  #
  # *** Hard links
  #
  mr -d . -n infusePostRebase
  #
  # *** DepoXy config
  #
  # Place the ~/.config/depoxy/depoxyrc config.
  # - Identifies the depoxy_client_id, even when the client is unmounted.
  #   Mostly necessary so DepoXy Ambers knows which `321open` to run.
  # - This file also sets custom paths, but I've never used that feature.
  # - Note this is the only file *copied* somewhere, and not symlinked,
  #   because it needs to be available when this project is not mounted.
  # Note this is not a symlink because repo might be offline.
  # FIXME: TRYME/2022-10-23: Could this be a hard link?
  #        - Or would the link get broken on unmount?
  # FIXME: You might want to diff this file and alert if user changed
  #        ~/.config copy, before clobber-overwriting.
  update_depoxy_configs () {
    # E.g., /Users/user/.config/depoxy
    local dxy_conf="${XDG_CONFIG_HOME:-${HOME}/.config}/depoxy"
    # E.g., .config/depoxy
    local conf_base="$(echo "${dxy_conf}" | sed -E "s@^${HOME}/@@")"
    #
    mkdir -p "${dxy_conf}"
    #
    copy_depoxy_config () {
      local file="$1"
      #
      local conf_source="${MR_REPO}/home/${conf_base}/${file}"
      local conf_target="${dxy_conf}/${file}"
      #
      # Avoid being aggressively clobbery.
      local conf_sha="${conf_target}.sha"
      if [ -f "${conf_target}" ] \
        && [ -f "${conf_sha}" ] \
        && ! shasum -c "${conf_sha}" > /dev/null 2>&1 \
      ; then
        # Note that `\\ \n` works, but not `\\\n`: "Within double quotes,
        # backslashes that are followed by one of these characters [including
        # backslash] are removed."
        >&2 error "ERROR: Did you edit the duplicate copy by mistake?\n" \
          "meld \\\\\n  ${conf_source} \\\\\n  ${conf_target} &\n" \
          "rm -- ${conf_target}"
        return 1
      fi
      #
      command cp -f -- "${conf_source}" "${conf_target}"
      #
      shasum "${conf_target}" > "${conf_sha}"
      #
      info "$(
        font_info_updated " Copied "
      ) $(
        font_emphasize "conf") replica $(
        font_highlight ${conf_target}
      )"
    }
    #
    copy_depoxy_config "depoxyrc"
    copy_depoxy_config "321open.cfg"
  }
  update_depoxy_configs
  #
  # *** DepoXy filespace
  #
  # See 'infusePostRebase' task for DXY_DEPOXYDIR_BASE_TILDE/.gitignore hard link.
  #
  # Create the DXY_DEPOXYDIR_RUNNING_TILDE ‚Üí DXY_DEPOXYDIR_STINTS_TILDE/XXXX symlink.
  # - Note that ${DEPOXY_CLIENT_ID} is from user's environ, which depends on
  #   this symlink probably having existed when ${DEPOXY_CLIENT_ID} was set.
  #   - So generally the symlink probably already exists, but if it was
  #     clobbered or changed you can repair it if you have a shell still
  #     using the proper client ID.
  #
  # See guard clause above: This call is a no-op:
  # - The symlink already exists and is correct.
  symlink_overlay_dir "${MR_REPO}" "${depoxydir_running_full}"
  #
  # *** OMR
  #
  # .mrinfuse/ nesting
  local dxy_home_work="${MR_REPO}/home/DXY_VENDOR_HOME_NAME"
  local usr_home_work="DXY_VENDOR_HOME__HOME_"
  local home_work_hint=""
  # These paths are part the Archetype boilerplate so exist initially,
  # but user may have moved or removed them.
  if [ ! -d "${dxy_home_work}" ]; then
    home_work_hint="No $(font_highlight ‚Äú${dxy_home_work}‚Äù) directory or symlink"
  elif [ ! -d "${usr_home_work}" ]; then
    home_work_hint="No $(font_highlight ‚Äú${usr_home_work}‚Äù) directory or symlink"
  fi
  if [ -n "${home_work_hint}" ]; then
    info "$( \
      font_emphasize "Skipped overlay" \
    ) ${dxy_home_work} ‚ÜØ ${usr_home_work}\n                             - ${home_work_hint}"
  else
    symlink_overlay_dir \
      "${dxy_home_work}" \
      "${VENDOR_HOME:-DXY_VENDOR_HOME__HOME_}/.mrinfuse"
    symlink_overlay_file \
      "${dxy_home_work}/_ignore" \
      "${VENDOR_HOME:-DXY_VENDOR_HOME__HOME_}/.ignore"
  fi
  #
  # Alert if missing business client mrconfig (because impossibly unlikely user won't want).
  # - E.g., "/home/user/.depoxy/stints"
  local stints_dir="${DEPOXYDIR_STINTS_FULL:-DXY_DEPOXYDIR_STINTS__HOME_}"
  # - E.g., "/home/user/.depoxy/stints/XXXX/.mrconfigs/_mrconfig-acme"
  local mr_business="${stints_dir}/DXY_DEPOXY_CLIENT_ID/.mrconfigs/_mrconfig-DXY_VENDOR_NAME"
  if [ ! -f "${mr_business}" ]; then
    info "$(font_emphasize ALERT): No biz config at $(repo_highlight ${mr_business})"
  fi
  #
  # *** DEPOXY
  #
  symlink_overlay_file \
    "${MR_REPO}/home/.depoxy/stints/_ignore" \
    "DXY_DEPOXYDIR_STINTS__HOME_/.ignore"
  #
  # *** BASH
  #
  # DepoXy's generated @biz-specific Bash files.
  # - DEV: Here's where to add your custom @biz-specific Bash:
  #     bashrx.private.DXY_USERNAME.sh.
  #     bashrx.private.DXY_HOSTNAME.sh.
  #   And wire more as you like.
  #
  local bashrx_host="${MR_REPO}/home/bashrx.private.DXY_HOSTNAME.sh"
  #
  if [ -f "${bashrx_host}" ]; then
    symlink_overlay_file \
      "${bashrx_host}" \
      "${HOMEFRIES_DIR:-${DOPP_KIT:-${HOME}/.kit}/sh/home-fries}/.bashrc-bin/bashrx.private.DXY_HOSTNAME.sh"
  else
    info "$(font_emphasize ALERT): No DXC bashrc at" \
      "$(repo_highlight ${bashrx_host})"
  fi
  # - ISOFF/2024-05-10: A filed named thusly would also be autoloaded by Homefries.
  #   - But we only need one autoload, then it can load (source) our other files.
  #
  #     local bashrx_user="bashrx.private.$(id -un).sh"
  #     local bashrx_full="${MR_REPO}/home/${bashrx_user}"
  #     #
  #     if [ -f "${bashrx_full}" ]; then
  #       symlink_overlay_file \
  #         "${bashrx_full}" \
  #         "${HOMEFRIES_DIR:-${HOME}/.kit/sh/home-fries}/.bashrc-bin/${bashrx_user}"
  #     fi
  #
  # - At an previous client, in the beginning, $(hostname) would report
  #   "HOST.DOMAIN.com". But then (months) later, $(hostname) started to
  #   say "HOST.DOMAIN.com.", with a trailing period. I never figured out
  #   why (or maybe I don't remember checking $(hostname), and really it
  #   was my code that changed?)
  #   - In any case, I doubt we need this version with two-dots:
  #
  #     symlink_overlay_file \
  #       "${MR_REPO}/home/bashrx.private.DXY_HOSTNAME.sh" \
  #       "${HOMEFRIES_DIR:-${DOPP_KIT:-${HOME}/.kit}/sh/home-fries}/.bashrc-bin/bashrx.private.DXY_HOSTNAME..sh"
  #
  # *** VIM
  #
  # Replace Vim spell file with symlink to user's version in DXC.
  cast_private_spell () {
    touch "${MR_REPO}/home/.vim/spell/en.utf-8.add"
    mkdir -p "${HOME}/.vim/spell"
    # DepoXy Ambers maintains ~/.mrinfuse, so currently cannot simply:
    #   symlink_mrinfuse_file "spell/en.utf-8.add"
    # but we could probably infuse the mrinfuse'r and then we could use
    # symlink_mrinfuse_file. But seems like unnecessary lift with no big
    # reward.
    symlink_overlay_file \
      "${MR_REPO}/home/.vim/spell/en.utf-8.add" \
      "${HOME}/.vim/spell/en.utf-8.add"
  }
  cast_private_spell
  #
  # Developer Vim tray: Custom Project Tray (Shift-Alt-3) Paths file.
  # - Add vendor-specific project listing to this file.
  symlink_overlay_file \
    "${MR_REPO}/home/.vim/pack/landonb/start/dubs_project_tray/.vimprojects" \
    "${HOME}/.vim/pack/landonb/start/dubs_project_tray/.vimprojects"
  # For the convenience.
  symlink_overlay_file \
    "home/.vim/pack/landonb/start/dubs_project_tray/.vimprojects" \
    "home/.vimprojects"
  #
  # Developer Vim grep: Custom Project Grep (\g) Paths list.
  # - Add vendor-specific project paths to this file.
  symlink_overlay_file \
    "${MR_REPO}/home/.vim/pack/landonb/start/dubs_grep_steady/dubs_projects.vim" \
    "${HOME}/.vim/pack/landonb/start/dubs_grep_steady/dubs_projects.vim"
  # Reload <\g> search list.
  # - If no such instance:
  #     E247: No registered server named "SAMPI": Send failed.
  gvim --servername "${GVIM_OPEN_SERVERNAME:-DXY_DEPOXY_GVIM_SERVERNAME}" \
    --remote-send "<ESC>:GrepSteadyReload<CR>" \
    2> /dev/null || true
  # For the convenience.
  symlink_overlay_file \
    "home/.vim/pack/landonb/start/dubs_grep_steady/dubs_projects.vim" \
    "home/dubs_projects.vim"
  #
  # Developer Vim plug: Custom plug at ~/.vim/pack/DepoXy/start/vim-trap
  # - Use this plugin for vendor-specific Vim config and commands.
  symlink_overlay_dir \
    "${MR_REPO}/home/vim-trap" \
    "${HOME}/.vim/pack/DepoXy/start/vim-trap"
  #
  # *** GIT
  #
  # Git user.name and user.email wirer.
  # - Depending on project path, Git will load either your personal
  #   user config, or it'll load your business user config.
  if [ -f "${MR_REPO}/home/.gitconfig.user" ]; then
    # BWARE: Ensure using @macOS `dash` not `/bin/bash --posix`
    # otherwise this MR_REPO is sticky, unless ( subshelled ).
    # - See commit comments for details: Search:
    #     Update: OMR: @macOS ... /bin/dash avoids ENV= bleed
    MR_REPO="${HOME}" symlink_mrinfuse_file ".gitconfig.user"
  else
    # This is a core DepoXy file, so would be unexpected if not found.
    warn "$(font_emphasize "Skipped .gitconfig.user")" \
      "/ See $(font_highlight ‚Äúarchetype/home/.gitconfig.user.EVAL‚Äù)"
  fi
  #
  # Enterprise Git: Your vendor-specific user.name and user.email.
  # - Used when committing work to vendor projects.
  if [ -f "${MR_REPO}/home/.gitconfig.user-business" ]; then
    MR_REPO="${HOME}" symlink_mrinfuse_file ".gitconfig.user-business"
  fi
  #
  # Your Personal Git: Your personal user.name and user.email.
  # - Used when committing work to this project (DXY_DEPOXY_CLIENT_ID)
  #   or any of your other (open source) projects you might have.
  if [ -f "${MR_REPO}/home/.gitconfig.user-personal" ]; then
    MR_REPO="${HOME}" symlink_mrinfuse_file ".gitconfig.user-personal"
  fi
  #
  # Private Git: A 'username@hostname' name for unpublished work.
  if [ -f "${MR_REPO}/home/.gitconfig.user-private" ]; then
    MR_REPO="${HOME}" symlink_mrinfuse_file ".gitconfig.user-private"
  fi
  #
  # `gh` and `hub` apps enterprise Git token.
  # - FIXME/2022-10-23: I removed ~/.github-token mechanism in favor
  #   of storing token in git remote URL, but I didn't test `hub`
  #   command (which I haven't used much recently).
  #   - So I may need to add `. ~/.github-token` back to private Bashrc.
  # - YOU: Make this manually. Don't need to keep in repo.
  #        See: DXY_DEPOXY_CLIENT_TILDE/home/bashrx.private.DXY_HOSTNAME.sh
  #  symlink_overlay_file \
  #    "${MR_REPO}/home/.github-token" \
  #    "${HOME}/.github-token"
  #
  # ~/.gitignore.local wiring
  symlink_overlay_dir \
    "${MR_REPO}/home/_git" \
    "${DEPOXYAMBERS_DIR:-${HOME}/.depoxy/ambers}/home/_git"
  #
  # See 'infusePostRebase' task for ~/.gitignore hard link.
  #
  # *** tig
  #
  # Note this overwrites DepoXy's ~/.depoxy/ambers/home/.config/tig/config
  # fallback symlink.
  mkdir -p "${HOME}/.config/tig"
  symlink_overlay_file \
    "${MR_REPO}/home/.config/tig/config" \
    "${HOME}/.config/tig/config"
  #
  #
  # *** NPM
  #
  # Enterprise NPM: Client-specific npm registry URL.
  if [ -f "${MR_REPO}/home/.npmrc" ]; then
    symlink_overlay_file \
      "${MR_REPO}/home/.npmrc" \
      "${HOME}/.npmrc"
  fi
  #
  # *** Karabiner-Elements
  #
  # CXREF: DepoXy Ambers KB infuser:
  #   infuse_symlinks_macOS_Karabiner_Elements_complex_modifications
  depoxy_client_infuse_karabiner_elements_complex_modifications () {
    local dxy_mrinfuse="${ambers_path}/home"
    local cmplxmods=".config/karabiner/assets/complex_modifications"
    # Symlink private KE cfg.
    local cbinfuser="${MR_REPO}/home"
    (
      cd "${dxy_mrinfuse}/${cmplxmods}"
      local jsonpath
      # Use -regex to exclude the 3110-client-DXY_DEPOXY_CLIENT_ID-private.json.example file.
      for jsonpath in $(find "${cbinfuser}/${cmplxmods}" -maxdepth 1 -type f -regex ".*\.json$"); do
        symlink_overlay_file "${jsonpath}"
      done
    )
  }
  depoxy_client_infuse_karabiner_elements_complex_modifications
  #
  # *** GNU Inetutils auto-login credentials
  #
  if [ -f "${HOME}/.netrc" ] && [ ! -h "${HOME}/.netrc" ]; then
    warn "Your ~/.netrc is not overseen by your DepoXy Client repo."
    info "Considering moving ~/.netrc inside your DepoXy Client and\n" \
      "                            letting DepoXy Client create a symlink for it at ~/.netrc."
    info "Try: \`mv \"${HOME}/.netrc\" \"${MR_REPO}/home/.netrc\" && infuse\`"
  elif [ -f "${MR_REPO}/home/.netrc" ]; then
    symlink_overlay_file \
      "${MR_REPO}/home/.netrc" \
      "${HOME}/.netrc"
  # else
  #   info " $(font_emphasize "Skipped .netrc")"
  fi
  #
  # *** ~/.finicky.js
  #
  symlink_overlay_file \
    "${MR_REPO}/home/.finicky.js" \
    "${HOME}/.finicky.js"
  #
  # *** ~/.kit
  #
  # What I call the Dopp Kit is where I clone most non-vendor projects,
  # e.g., various Git projects, useful shell utilities, and more. Most
  # of the projects are public/open source and installed by the public
  # DepoXy Ambers project. But you'll probably add additional projects
  # to pair with the vendor code you work on (you can add each project
  # to the _mrconfig-vendor included at the end of this file). Here we
  # install a ~/.kit/.git/info/exclude file (and I know, this function
  # looks more complicated, but really that's all it does).
  user_home_kit_link_private_exclude () {
    # ~/.kit/.gitignore.local wiring.
    #
    # First wire the mrinfuse path.
    symlink_overlay_dir \
      "${MR_REPO}/home/.kit/_git" \
      "${DEPOXYAMBERS_DIR:-${HOME}/.depoxy/ambers}/home/.kit/_git"
    #
    # Next, call the internal that link_private_exclude calls, but skip
    # link_private_exclude, because we need to kludge around ${MR_REPO}.
    local kit_path="${DOPP_KIT:-${HOME}/.kit}"
    local before_cd="$(pwd -L)"
    local before_mr="${MR_REPO}"
    # Such sneaky:
    MR_REPO="${kit_path}"
    cd "${MR_REPO}"
    link_exclude_resolve_source_and_overlay
    MR_REPO="${before_mr}"
    cd "${before_cd}"
  }
  user_home_kit_link_private_exclude
  #
  # *** ~/.kube
  #
  # MAYBE/2022-12-14: Move this elsewhere, and keep core DepoXy infuse
  # steps separate from steps associated with clients or specifically
  # developing.
  #
  # OpenLens doesn't show any clusters when yaml symlinks used, so
  # wiring yamls (and config, for parity) using hard links.
  if [ -f "${MR_REPO}/home/.kube/config" ]; then
    mkdir -p "${HOME}/.kube"
    #
    # NOPE: Docker Desktop edits main kube config, e.g., changing
    #       `client-certificate-data` and `client-key-data`, and setting
    #       and unsetting `namespace`.
    #         link_hard \
    #           "${MR_REPO}/home/.kube/config" \
    #           "${HOME}/.kube/config"
    # - We'll copy canon file and autocommit just to track it; see autocommit.
  fi
  #
  # See 'infusePostRebase' task for ~/.kube hard links.
  #
  # Alert user if AWS config perhaps not configured appropriately.
  if [ -n "$(ls ~/.kube/*.yaml 2> /dev/null)" ]; then
    if command rg "command: aws" ~/.kube/*.yaml > /dev/null 2>&1; then
      warn
      warn "BWARE: You probably need to use an absolute path to AWS in your kubeconfig."
      warn
      warn "- Instead of using a relative path:"
      warn
      warn "    command: aws"
      warn
      warn "- You probably need to use an absolute path:"
      warn
      warn "    command: $(command -v aws)"
      warn
      warn "- See the following file(s):"
      warn
      command rg "command: aws" ~/.kube/*.yaml
    fi
  fi
  #
  # *** dob
  #
  infuse_dob_config_if_exists () {
    (
      cd "${HOME}"
      # Install "${XDG_CONFIG_HOME:-${HOME}/.config}/dob"
      MR_REPO="${HOME}"
      local sourcep
      if sourcep="$(path_to_mrinfuse_resolve ".config/dob")" \
        && [ -d "${sourcep}" ] \
      ; then
        symlink_mrinfuse_dir '.config/dob'
      fi
    )
  }
  infuse_dob_config_if_exists

# ========================================================================
# ------------------------------------------------------------------------

# YOU: Add client-specific projects to the another config, e.g.,:
#        DXY_DEPOXYDIR_RUNNING_TILDE/.mrconfigs/_mrconfig-DXY_VENDOR_NAME
#      and reserve this mrconfig for the DepoXy Client project
#      (so you can more easily keep it synced with the upstream).

[DEFAULT]
order = 220
include =
  # Load task helpers (that higher-level OMR config doesn't load, because
  # neither DepoXy Ambers nor Oh My Repos! uses this functionality).
  #
  # ***
  #
  include_git_hooks_rewire () {
    cat "${OHMYREPOS_LIB:-${HOME}/.ohmyrepos/lib}/git-hooks-rewire"
  }
  include_git_hooks_rewire
  #
  # ***
  #
  # Load lib fcn `hack_patch_opn_to_call_sensible_open`.
  include_js_npm_patch_opn_sensible_open () {
    local ambers_path="${DEPOXYAMBERS_DIR:-DXY_DEPOXYAMBERS_DIR__HOME_}"
    # CXREF: DXY_DEPOXYAMBERS_DIR_TILDE/home/.kit/git/ohmyrepos/lib/js-npm-patch-opn-sensible-open
    cat "${ambers_path}/home/.kit/git/ohmyrepos/lib/js-npm-patch-opn-sensible-open"
  }
  include_js_npm_patch_opn_sensible_open
  #
  # ***
  #
  # Load vendor-specific OMR project config.
  include_depoxy_client_mr_business () {
    . ${OHMYREPOS_LIB:-${GITREPOSPATH:-${HOME}/.kit/git}/ohmyrepos/lib}/skip-grouping.sh
    #
    local stints_dir="${DEPOXYDIR_STINTS_FULL:-DXY_DEPOXYDIR_STINTS__HOME_}"
    # CXREF: DXY_DEPOXYDIR_STINTS_TILDE/DXY_DEPOXY_CLIENT_ID/.mrconfigs/_mrconfig-DXY_VENDOR_NAME
    #        DXY_DEPOXYARCHETYPE_DIR_TILDE/.mrconfigs/_mrconfig-VENDOR_NAME.EVAL
    local mr_business="${stints_dir}/DXY_DEPOXY_CLIENT_ID/.mrconfigs/_mrconfig-DXY_VENDOR_NAME"
    if [ -f "${mr_business}" ] && ! (
        mr_exclusive "business" "vendor" "DXY_VENDOR_HOME_NAME" &&
        true
      );
    then
      mr_cat "${mr_business}"
    fi
  }
  include_depoxy_client_mr_business
  #
  # ***
  #
  # Load user-specific OMR project config.
  include_depoxy_client_mr_personal () {
    . ${OHMYREPOS_LIB:-${GITREPOSPATH:-${HOME}/.kit/git}/ohmyrepos/lib}/skip-grouping.sh
    #
    local stints_dir="${DEPOXYDIR_STINTS_FULL:-DXY_DEPOXYDIR_STINTS__HOME_}"
    # CXREF: DXY_DEPOXYDIR_STINTS_TILDE/DXY_DEPOXY_CLIENT_ID/.mrconfigs/_mrconfig-DXY_USERNAME
    #        DXY_DEPOXYARCHETYPE_DIR_TILDE/.mrconfigs/_mrconfig-USERNAME.EVAL
    local mr_personal="${stints_dir}/DXY_DEPOXY_CLIENT_ID/.mrconfigs/_mrconfig-DXY_USERNAME"
    if [ -f "${mr_personal}" ] && ! (
        mr_exclusive "personal" "user" "DXY_USERNAME" &&
        true
      );
    then
      mr_cat "${mr_personal}"
    fi
  }
  include_depoxy_client_mr_personal

# ========================================================================
# ------------------------------------------------------------------------

# SAVVY: Include this last so that its projects override previous config.

[DEFAULT]
include =
  if echo "${MR_ACTION}" | grep -q "Remotes$"; then
    # CXREF: DXY_DEPOXYDIR_RUNNING_TILDE/.mrconfigs/_mrconfig-remotes
    mr_cat "${DEPOXYDIR_RUNNING_FULL:-${HOME}/.depoxy/running}/.mrconfigs/_mrconfig-remotes"
  fi

# ========================================================================
# ------------------------------------------------------------------------

